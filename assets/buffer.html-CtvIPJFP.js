import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a as t,o as i}from"./app-Cg0pGZ9O.js";const n={};function l(d,e){return i(),r("div",null,[...e[0]||(e[0]=[t('<h1 id="buffer" tabindex="-1"><a class="header-anchor" href="#buffer"><span>Buffer</span></a></h1><p><code>silly.adt.buffer</code> 是一个高效的字节缓冲区实现，用于处理网络数据流的拼接和解析。</p><h2 id="引入模块" tabindex="-1"><a class="header-anchor" href="#引入模块"><span>引入模块</span></a></h2><div class="language-lua line-numbers-mode" data-highlighter="shiki" data-ext="lua" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-lua"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">local</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">require</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;silly.adt.buffer&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="api-参考" tabindex="-1"><a class="header-anchor" href="#api-参考"><span>API 参考</span></a></h2><h3 id="buffer-new" tabindex="-1"><a class="header-anchor" href="#buffer-new"><span>buffer.new()</span></a></h3><p>创建一个新的缓冲区对象。</p><ul><li><strong>返回值</strong>: <code>buffer</code> - 新的缓冲区对象</li></ul><h3 id="buffer-append-data" tabindex="-1"><a class="header-anchor" href="#buffer-append-data"><span>buffer:append(data [, ...])</span></a></h3><p>向缓冲区追加数据。</p><ul><li><strong>参数</strong>: <ul><li><code>data</code>: <code>string</code> | <code>lightuserdata</code> - 要追加的数据</li><li><code>...</code>: <code>string</code> | <code>lightuserdata</code> - 更多数据</li></ul></li><li><strong>返回值</strong>: <code>integer</code> - 缓冲区当前的总字节数</li><li><strong>说明</strong>: <ul><li>如果参数是 <code>lightuserdata</code>，则必须紧跟一个 <code>integer</code> 类型的长度参数。</li><li>例如: <code>buf:append(ptr, len)</code></li></ul></li></ul><h3 id="buffer-read-n" tabindex="-1"><a class="header-anchor" href="#buffer-read-n"><span>buffer:read(n)</span></a></h3><p>从缓冲区读取指定长度的数据。</p><ul><li><strong>参数</strong>: <ul><li><code>n</code>: <code>integer</code> - 要读取的字节数</li></ul></li><li><strong>返回值</strong>: <ol><li><code>string|nil</code> - 读取的数据，如果缓冲区数据不足则返回 <code>nil</code></li><li><code>integer</code> - 缓冲区剩余字节数</li></ol></li></ul><h3 id="buffer-read-delim" tabindex="-1"><a class="header-anchor" href="#buffer-read-delim"><span>buffer:read(delim)</span></a></h3><p>从缓冲区读取直到遇到指定分隔符的数据（包含分隔符）。</p><ul><li><strong>参数</strong>: <ul><li><code>delim</code>: <code>string</code> - 分隔符（必须是单字符字符串）</li></ul></li><li><strong>返回值</strong>: <ol><li><code>string|nil</code> - 读取的数据（包含分隔符），如果未找到分隔符则返回 <code>nil</code></li><li><code>integer</code> - 缓冲区剩余字节数</li></ol></li></ul><h3 id="buffer-readall" tabindex="-1"><a class="header-anchor" href="#buffer-readall"><span>buffer:readall()</span></a></h3><p>读取缓冲区中的所有数据。</p><ul><li><strong>返回值</strong>: <code>string</code> - 缓冲区中的所有数据</li></ul><h3 id="buffer-clear" tabindex="-1"><a class="header-anchor" href="#buffer-clear"><span>buffer:clear()</span></a></h3><p>清空缓冲区。</p><h3 id="buffer-size" tabindex="-1"><a class="header-anchor" href="#buffer-size"><span>buffer:size()</span></a></h3><p>获取缓冲区当前包含的字节数。</p><ul><li><strong>返回值</strong>: <code>integer</code> - 字节数</li></ul><h3 id="buffer-dump" tabindex="-1"><a class="header-anchor" href="#buffer-dump"><span>buffer:dump()</span></a></h3><p>获取缓冲区的调试信息。</p><ul><li><strong>返回值</strong>: <code>table</code> - 包含缓冲区内部状态的表</li></ul>',28)])])}const c=a(n,[["render",l]]),f=JSON.parse('{"path":"/reference/adt/buffer.html","title":"Buffer","lang":"zh-CN","frontmatter":{"description":"Buffer silly.adt.buffer 是一个高效的字节缓冲区实现，用于处理网络数据流的拼接和解析。 引入模块 API 参考 buffer.new() 创建一个新的缓冲区对象。 返回值: buffer - 新的缓冲区对象 buffer:append(data [, ...]) 向缓冲区追加数据。 参数: data: string | light...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Buffer\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-11-22T01:39:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"重归混沌\\",\\"url\\":\\"https://blog.gotocoding.com\\"}]}"],["meta",{"property":"og:url","content":"https://gotocoding.com/silly/reference/adt/buffer.html"}],["meta",{"property":"og:site_name","content":"参考手册"}],["meta",{"property":"og:title","content":"Buffer"}],["meta",{"property":"og:description","content":"Buffer silly.adt.buffer 是一个高效的字节缓冲区实现，用于处理网络数据流的拼接和解析。 引入模块 API 参考 buffer.new() 创建一个新的缓冲区对象。 返回值: buffer - 新的缓冲区对象 buffer:append(data [, ...]) 向缓冲区追加数据。 参数: data: string | light..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-11-22T01:39:53.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-22T01:39:53.000Z"}],["link",{"rel":"alternate","hreflang":"en-us","href":"https://gotocoding.com/silly/en/reference/adt/buffer.html"}]]},"git":{"createdTime":1763775593000,"updatedTime":1763775593000,"contributors":[{"name":"findstr","username":"findstr","email":"findstr@sina.com","commits":1,"url":"https://github.com/findstr"}]},"readingTime":{"minutes":1.2,"words":361},"filePathRelative":"reference/adt/buffer.md","autoDesc":true}');export{c as comp,f as data};
