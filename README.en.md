# Silly - Lightweight Server Framework
[![license](https://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat)](https://github.com/findstr/silly/blob/master/LICENSE)
[![CI](https://github.com/findstr/silly/actions/workflows/ci.yml/badge.svg)](https://github.com/findstr/silly/actions/workflows/ci.yml)
[![cn](https://img.shields.io/badge/lang-cn-red.svg)](./README.md)

Silly is a lightweight and minimalist server framework.

## Features

- **Developed with a mix of C and Lua**: The core is developed in C, while the upper business logic is primarily in Lua.
- **Single-process single-thread model**: Suitable for traditional game development, avoiding multi-threading concurrency issues.
- **Avoids callback hell**: Utilizes Lua coroutines to handle asynchronous calls.

## Performance Testing

The `redis-benchmark` program is used for concurrency testing.

Test machine: `CPU: Intel(R) Core(TM) i5-4440 CPU @ 3.10GHz`.

[Test code](https://github.com/findstr/silly/wiki/Benchmark) results are as follows:

```
   ====== PING_INLINE ======
     100000 requests completed in 0.76 seconds
     1000 parallel clients
     3 bytes payload
     keep alive: 1

   0.00% <= 2 milliseconds
   0.03% <= 3 milliseconds
   70.15% <= 4 milliseconds
   99.35% <= 5 milliseconds
   99.70% <= 6 milliseconds
   99.98% <= 7 milliseconds
   100.00% <= 7 milliseconds
   131926.12 requests per second

   ====== PING_BULK ======
     100000 requests completed in 0.77 seconds
     1000 parallel clients
     3 bytes payload
     keep alive: 1

   0.00% <= 2 milliseconds
   0.08% <= 3 milliseconds
   87.33% <= 4 milliseconds
   99.45% <= 5 milliseconds
   99.76% <= 6 milliseconds
   100.00% <= 6 milliseconds
   130378.09 requests per second
```

## Compilation

##### Install Dependencies

###### Debian System

```bash
apt-get install libreadline-dev
```

###### CentOS System

```bash
yum install readline-devel
```

```bash
make
```

## Running

```bash
./silly <main.lua> [options]
```

## Working Principle

Although Silly uses three threads in its implementation, the threads do not share data. The business logic is executed in a single thread, so the business layer perceives it as a single-process single-thread model.

Here is how Silly works:

##### Thread Division

1. **Worker Thread**:
   - Runs on the Lua virtual machine, handling all events generated by sockets and timers.
   - After an event is triggered, the Worker thread converts it to the Lua layer for processing.

2. **Socket Thread**:
   - Provides efficient socket management based on `epoll/kevent/iocp`, encapsulating socket data transmission, closure, and connection events.
   - Supports up to 65535 socket connections, adjustable via the `SOCKET_MAX_EXP` macro in the `silly_conf.h` file.
   - Can be easily replaced with other required IO models, as long as they conform to the `event.h` interface definition.

3. **Timer Thread**:
   - Provides high-resolution, low-precision timers with a default resolution of 10ms and an accuracy of 50ms. The resolution and accuracy can be adjusted by modifying the `TIMER_RESOLUTION` and `TIMER_ACCURACY` macros in `silly_conf.h`.

## Examples

Silly provides multiple examples.

- [http](examples/http.lua)
- [patch](examples/patch.lua)
- [rpc](examples/rpc.lua)
- [socket](examples/socket.lua)
- [timer](examples/timer.lua)
- [websocket](examples/websocket.lua)

You can run the following scripts to start different examples:

```lua
examples/start.sh http
examples/start.sh patch
examples/start.sh rpc
examples/start.sh socket
examples/start.sh timer
examples/start.sh websocket
```

If you want to run all examples at once, execute:

```bash
examples/start.sh
```

## Testing

All module test codes are located in the test folder. You can run the tests with the following command:

```bash
make testall
```

## Wiki
Feel free to check the [Wiki documentation](https://github.com/findstr/silly/wiki) for more information.